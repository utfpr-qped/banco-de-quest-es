{"sortingAlgorithms":[{"id":"ordenacao-método-bolha","subject":"Algoritmos de ordenação","text":"\nQuantas trocas são necessárias para que a sequência \n```\n{sequencia=1:10:{6:10}}\n``` \n\nseja ordenada pelo método:\n```\n{metodo}\n```\n<metodo>\n  <item value=\"bubbleSort1\">\n  void bubbleSort(int arr[], int n) \\{\n    int i, j;\n    for (i=0; i &lt; n-1; i++)\\{\n      for(j=1; j &lt; n-i; j++) \\{\n        if (arr[j-1] &gt; arr[j]) \\{\n          troca(&amp;arr[j], &amp;arr[j-1]);\n        \\}\n      \\}\n    \\}\n  \\}\n  </item>\n  <item value=\"bubbleSort2\">\n  void bubbleSort(int arr[], int n)\\{\n    int i, j;\n    for (i=0; i &lt; n-1; i++)\\{\n      for(j=1; j &lt; n-i; j++) \\{\n        if (arr[j-1] &lt; arr[j]) \\{\n          troca(&amp;arr[j], &amp;arr[j-1]);\n        \\}\n      \\}\n    \\}\n  \\}\n  </item>\n  <item value=\"bubbleSort3\">\n  void bubbleSort(int arr[], int n)\\{\n    int i, j;\n    for (i=0; i &lt; n-1; i++)\\{\n      for(j=n; j &gt; i; j++) \\{\n        if (arr[j-1] &gt; arr[j]) \\{\n          troca(&amp;arr[j], &amp;arr[j-1]);\n        \\}\n      \\}\n    \\}\n  \\}\n  </item>\n  <item value=\"bubbleSort4\">\n  void bubbleSort(int arr[], int n)\\{\n    int i, j;\n    for (i=0; i &lt; n-1; i++)\\{\n      for(j=n; j &gt; i; j++) \\{\n        if (arr[j] &gt; arr[j-1]) \\{\n          troca(&amp;arr[j], &amp;arr[j-1]);\n        \\}\n      \\}\n    \\}\n  \\}\n  </item>\n</metodo>\n      ","answer":"function (values, blocks) {\n        const arr = [...values.sequencia]\n        const metodo = blocks.metodo\n        const resp = []\n        \n        let troca = function(vet, i, j) {\n          let aux = vet[i];\n          vet[i] = vet[j];\n          vet[j] = aux;\n        }\n\n        let fncs = {\n          'bubbleSort1': function(arr, n) {\n            let i, j, t=0;\n            for (i=0; i < n-1; i++){\n              for(j=1; j < n-i; j++){\n                if (arr[j-1] > arr[j]){\n                  t++;\n                  troca(arr, j-1, j);\n                }\n              }\n            }\n            return t;\n          },\n\n          'bubbleSort2': function(arr, n) {\n            let i, j, t=0;\n            for (i=0; i < n-1; i++){\n              for(j=1; j < n-i; j++){\n                if (arr[j-1] < arr[j]){\n                  t++;\n                  troca(arr, j-1, j);\n                }\n              }\n            }\n            return t;\n          },\n\n          'bubbleSort3': function(arr, n) {\n            let i, j, t;\n            t=0;\n            for (i=0; i < n-1; i++){\n              for(j=n; j > i; j--){\n                if (arr[j-1] > arr[j]){\n                  t++;\n                  troca(arr, j-1, j);\n                }\n              }\n            }\n            return t;\n          },\n\n          'bubbleSort4': function(arr, n) {\n            let i, j, t;\n            t=0;\n            for (i=0; i < n-1; i++){\n              for(j=n; j > i; j--){\n                if (arr[j] > arr[j-1]){\n                  t++;\n                  troca(arr, j-1, j);\n                }\n              }\n            }\n            return t;\n          }\n        };\n\n        resp.push(fncs[metodo](arr, arr.length));\n        return resp;\n      }","level":2,"keywords":["bubble-sort","ordenação","trocas","teste de mesa"]},{"id":"ordenação-método-seleção","subject":"Algoritmos de ordenação","text":"\nQuantas trocas são necessárias para que a sequência \n```\n{sequencia=1:10:{6:10}}\n``` \n\nseja ordenada pelo método:\n```\n{metodo}\n```      <metodo>\n  <item value=\"selectionSort1\">\n  void selection(int vet[], int n) \\{\n    int i, j, x;\n    for (i=0; i &lt; n-1; i++) \\{\n      x = i;\n      for (j=i+1; j &lt; n; j++) \\{\n        if (vet[j] &lt; vet[x]) \\{\n          x = j;\n        \\}\n        if (x != i) \\{\n          troca(&amp;vet[x], &amp;vet[i]);\n        \\}\n      \\}\n    \\}\n  \\}\n  </item>\n  <item value=\"selectionSort2\">\n  void selection(int vet[], int n) \\{\n    int i, j, x;\n    for (i=0; i &lt; n-1; i++) \\{\n      x = i;\n      for (j=i+1; j &lt; n; j++) \\{\n        if (vet[j] &gt; vet[x]) \\{\n          x = j;\n        \\}\n        if (x != i) \\{\n          troca(&amp;vet[x], &amp;vet[i]);\n        \\}\n      \\}\n    \\}\n  \\}\n  </item>\n</metodo>\n      ","answer":"function (values, blocks) {\n        const arr = [...values.sequencia]\n        const metodo = blocks.metodo\n        const resp = []\n        \n        let troca = function(vet, i, j) {\n          let aux = vet[i];\n          vet[i] = vet[j];\n          vet[j] = aux;\n        }\n\n        let fncs = {\n          'selectionSort1': function(arr, n) {\n            let i, j, x, t;\n            t=0;\n            for (i=0; i < n-1; i++){\n              x = i;\n                for(j=i+1; j<n; j++){\n                  if (arr[j] < arr[x]) {\n                    x = j;\n                }\t\n              }\n              if (x != i) {\n              t++;\n                  troca(arr, x, i);\n              }\n            }\n            return t;\n          },\n\n          'selectionSort2': function(arr, n) {\n            let i, j, x, t;\n            t=0;\n            for (i=0; i < n-1; i++){\n              x = i;\n                for(j=i+1; j<n; j++){\n                  if (arr[j] > arr[x]) {\n                    x = j;\n                }\t\n              }\n              if (x != i) {\n              t++;\n                  troca(arr, x, i);\n              }\n            }\n            return t;\n          }\n        };\n\n        resp.push(fncs[metodo](arr, arr.length));\n        return resp;\n      }","level":2,"keywords":["selection-sort","ordenação","trocas","teste de mesa"]},{"id":"ordenação-método-inserção","subject":"Algoritmos de ordenação","text":"\nQuantas trocas são necessárias para que a sequência \n```\n{sequencia=1:10:{6:10}}\n``` \n\nseja ordenada pelo método:\n```\n{metodo}\n```      \n<metodo>\n  <item value=\"insertionSort1\">\n  void insertion(int vet[], int n) \\{\n    int i, j;\n    for (i=1; i &lt; n; i++) \\{\n      for (j=i; j &gt; 0 &amp;&amp; vet[j] &lt; vet[j-1]; j--) \\{\n        troca(&amp;vet[j-1], &amp;vet[j]);\n      \\}\n    \\}\n  \\}\n  </item>\n  <item value=\"insertionSort2\">\n  void insertion(int vet[], int n) \\{\n      int i, j;\n      for (i=1; i &lt; n; i++) \\{\n        for (j=i; j &gt; 0 &amp;&amp; vet[j-1] &lt; vet[j]; j--) \\{\n          troca(&amp;vet[j-1], &amp;vet[j]);\n        \\}\n      \\}\n    \\}\n  \\}\n  </item>\n  <item value=\"insertionSort3\">\n  void insertion(int vet[], int n) \\{\n  \tint i, j;\n  \tfor (i = 1; i &lt; n; i++) \\{\n      j = i - 1;\n      while (j &gt;= 0 &amp;&amp; vet[j] &gt; vet[j+1]) \\{\n          troca(vet[j], vet[j+1]);\n          j = j - 1;\n      \\}\n    \\}\n  \\}\n  </item>\n</metodo>\n      ","answer":"function (values, blocks) {\n        const arr = [...values.sequencia]\n        const metodo = blocks.metodo\n        const resp = []\n        \n        let troca = function(vet, i, j) {\n          let aux = vet[i];\n          vet[i] = vet[j];\n          vet[j] = aux;\n        }\n\n        let fncs = {\n          'insertionSort1': function(arr, n) {\n            let i, j, t;\n            t=0;\n            for (i=1; i<n; i++) {\n              for (j=i; j>0 && arr[j]<arr[j-1]; j--) {\n              t++;\n                  troca(arr, j-1, j);\n              }\n            }\n            return t;\n          },\n\n          'insertionSort2': function(arr, n) {\n            let i, j, t;\n            t=0;\n            for (i=1; i<n; i++) {\n              for (j=i; j>0 && arr[j-1]<arr[j]; j--) {\n              t++;\n                  troca(arr, j-1, j);\n              }\n            }\n            return t;\n          },\n\n          'insertionSort3': function(arr, n) {\n            let i, j, t;\n            t=0;\n            for (i = 1; i < n; i++) {\n              j = i - 1;\n              while (j >= 0 && arr[j] > arr[j+1]) {\n                t++;\n                troca(arr, j, j+1);\n                j = j - 1;\n              }\n            }\n            return t;\n          }\n        };\n\n        resp.push(fncs[metodo](arr, arr.length));\n        return resp;\n      }","level":2,"keywords":["insertion-sort","ordenação","trocas","teste de mesa"]},{"id":"ordenação-método-quicksort","subject":"Algoritmos de ordenação","text":"\nConsiderando que o método quick-sort seja aplicado para ordenar o conjunto de dados a seguir\n```\n{sequencia=1:20:{10:13}}\n``` \n\nConsiderando que na primeira iteração, o valor {sequencia[{pivo=1:9}]} = **{sequencia[{pivo}]}** / {pivo} é o pivô escolhido.\nQual será sua posição após a primeira iteração?\n      ","answer":"function (values, blocks) {\n        const arr = [...values.sequencia]\n        const pivo = values.pivo\n        const resp = []\n\n        let c = 0;\n        for (let i = 0; i<arr.length; i++) {\n          if (arr[i] < arr[pivo]) c++;\n        }\n        if (c == 0)\n          resp.push(0)\n        else\n          resp.push(c - 1);\n\n        return resp;\n      }","level":2,"keywords":["quick-sort","ordenação"]}],"searchingAlgorithms":[{"id":"busca-sequencial-comparação","subject":"Algoritmos de busca","text":"\nSuponha que você está realizando uma busca sequencial no vetor: `[{vet=3:13:+{6:11}}]`\n\nQuantas comparações serão realizadas se o valor buscado for **{valor=3:13}**?\n      }","answer":"function (values) {\n        const { vet, valor } = values\n        let answer = []// resposta a ser retornada\n\n        for (let i = 0; i < vet.length; i++) {\n          if (vet[i] == valor) {\n            answer.push(i + 1)\n            return answer\n          }\n        }\n\n        answer.push(vet.length) \n        return answer\n      }","level":1,"keywords":["busca sequencial","busca"]},{"id":"busca-sequencial-retorno","subject":"Algoritmos de busca","text":"Considere o método de busca sequencial em um vetor contendo os elementos: `[{vet=2:23:+{5:10}}]` \n      \nQual deve ser o retorno da busca quando o usuário pesquisar pelo item **{valor=2:23}**?\n      ","answer":"function (values) {\n        const { vet, valor } = values\n        let answer = []\n\n        for (let i = 0; i < vet.length; i++) {\n          if (vet[i] == valor) {\n            answer.push(i)\n            return answer\n          }\n        }\n\n        answer.push(-1)\n        return answer\n      }","level":1,"keywords":["busca sequencial","busca"]},{"id":"busca-sequencial-otimizada","subject":"Algoritmos de busca","text":"\nSuponha que seja feita uma busca sequencial otimizada no vetor a seguir, o qual deve ser ordenado antes da busca. \n```\n[{vet=1:10:{5:10}}]\n``` \nQuantas comparações serão realizadas se o valor a ser buscado for **{valor=1:10}**?\n    ","answer":"function (values) {\n        const { vet, valor } = values\n        const answer = []\n\n        const BubbleSort = originalArray => {\n          // Make a copy of the original array\n          let arr = [...originalArray]\n\n          let swapped;\n          do {\n            swapped = false;\n            for (let i = 0; i < arr.length; i++) {\n              if (arr[i] > arr[i + 1]) {\n                let tmp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = tmp;\n                swapped = true;\n              }\n            }\n          } while (swapped);\n          return arr;\n        }\n\n        // Ordenar vetor usando Bubble Sort\n        let sortedArray = BubbleSort(vet)\n\n        // Realizar busca sequencial no vetor ordenado\n        for (let i = 0; i < sortedArray.length; i++) {\n          if (sortedArray[i] == valor) {\n            answer.push(i + 1)\n            return answer\n          }\n        }\n\n        answer.push(sortedArray.length)\n        return answer\n      }","level":1,"keywords":["busca","busca otimizada","busca sequencial"]}],"stack":[{"id":"pilha-div","subject":"Pilha estática e dinâmica","text":"\nConsiderando a função a seguir que recebe dois valores como argumentos e utiliza a pilha S para processá-los.\n\nO que será impresso quando **fun({n=6:12}, {d=2:5})** for chamado?\n```\nvoid fun(int n, int d) {\n  stack S; \n  while (n >= 1) {\n    push(&S, n%d);\n    n = n/d;\n  \\}\n  while (!isEmpty(&S))\n    printf(\"%d \", pop(&S));\n\\}\n```\n","answer":"function (values) {\n        let n = parseInt(values.n)\n        let d = parseInt(values.d)\n        let stack = []\n\n        let poppedItems = []\n\n        while (n >= 1) {\n          stack.push(n % d)\n          n = parseInt(n / d)\n        }\n        \n        while (stack.length) {\n          poppedItems.push(stack.pop())\n        }\n\n        return poppedItems\n      }","level":1,"keywords":["pilha","simulação","teste de mesa"]},{"id":"pilha-op","subject":"Pilha estática e dinâmica","text":"\nSe a seguinte sequência de operações é realizada com uma pilha: \n```\n{sequencia}\n```\n\nEm qual ordem os elementos serão removidos da pilha?\n\n<sequencia>\n  <item value=\"1\">\n  push({a=1:3}), push({b=1:3}), pop(), push({c=1:3}), push({d=1:3}), pop(), pop(), pop(), push({e=1:3}), pop()\n  </item>\n  <item value=\"2\">\n  push({a=1:3}), pop(), push({b=1:3}), push({c=1:3}), pop(), push({d=1:3}), pop(), pop(), push({e=1:3}), pop()\n  </item>\n  <item value=\"3\">\n  push({a=1:3}), pop(), push({b=1:3}), pop(), push({c=1:3}), push({d=1:3}), pop(), push({e=1:3}), pop(), pop()\n  </item>\n  <item value=\"4\">\n  push({a=1:3}), pop(), push({b=1:3}), push({c=1:3}), push({d=1:3}), pop(), push({e=1:3}), pop(), pop(), pop()\n  </item>\n  <item value=\"4\">\n  push({a=1:3}), push({b=1:3}), push({c=1:3}), pop(), push({d=1:3}), pop(), pop(), push({e=1:3}), pop(), pop()\n  </item>\n</sequencia>\n","answer":"function (values, options) {\n        let a = parseInt(values.a)\n        let b = parseInt(values.b)\n        let c = parseInt(values.c)\n        let d = parseInt(values.d)\n        let e = parseInt(values.e)\n        let item = parseInt(options.sequencia)\n        let stack = []\n\n        let poppedItems = []\n        switch(item) {\n          case 1:\n            stack.push(a); stack.push(b); poppedItems.push(stack.pop()); stack.push(c); stack.push(d); poppedItems.push(stack.pop()); poppedItems.push(stack.pop()); poppedItems.push(stack.pop()); stack.push(e); poppedItems.push(stack.pop());\n            break;\n          case 2:\n            stack.push(a); poppedItems.push(stack.pop()); stack.push(b); stack.push(c); poppedItems.push(stack.pop()); stack.push(d); poppedItems.push(stack.pop()); poppedItems.push(stack.pop()); stack.push(e); poppedItems.push(stack.pop());\n            break;\n          case 3:\n            stack.push(a); \n            poppedItems.push(stack.pop());\n            stack.push(b); \n            poppedItems.push(stack.pop());\n            stack.push(c); \n            stack.push(d);\n            poppedItems.push(stack.pop());\n            stack.push(e);\n            poppedItems.push(stack.pop());\n            poppedItems.push(stack.pop());\n            break;\n          case 4:\n            stack.push(a); \n            poppedItems.push(stack.pop());\n            stack.push(b); \n            stack.push(c); \n            stack.push(d);\n            poppedItems.push(stack.pop());\n            stack.push(e);\n            poppedItems.push(stack.pop());\n            poppedItems.push(stack.pop());\n            poppedItems.push(stack.pop());\n            break;\n          case 5:\n            stack.push(a); \n            stack.push(b); \n            stack.push(c); \n            poppedItems.push(stack.pop());\n            stack.push(d);\n            poppedItems.push(stack.pop());\n            poppedItems.push(stack.pop());\n            stack.push(e);\n            poppedItems.push(stack.pop());\n            poppedItems.push(stack.pop());\n            break;\n        }\n        \n        return poppedItems\n      }","level":1,"keywords":["pilha","simulação","teste de mesa"]}],"queue":[{"id":"fila-básico","subject":"Fila estática e dinâmica","text":"Se os elementos abaixo são adicionados a uma fila e são depois removidos da fila, em qual ordem eles serão removidos? `[{vet=1:10:{3:6}}]`","answer":"function (values) {\n        const { vet } = values\n        let inputArr = [...vet]// copiar o vetor\n        let answer = []// resposta a ser retornada\n        while (inputArr.length) {\n          answer.push(inputArr.shift())\n        }\n        return answer\n      }","level":1,"keywords":["ordem de remoção","fila"]},{"id":"fila-pilha","subject":"Fila estática e dinâmica","text":"\nConsiderando a função f a seguir, qual será a nova ordem da fila se a função f for chamada recebendo a fila **[{vet=1:10:{3:6}}]**?\n```\n  void f(queue *q)\\{\n    int aux;\n    stack *s = criaStack();  \n\n    while (!isEmpty(q)) \\{\n      aux = dequeue(q);\n      if (aux % 2 == 1)\n        push(s, aux);\n      else\n        enqueue(q, aux+1);\n    \\}\n\n    while (!isEmpty(s)) \\{\n      enqueue(q, pop(s));\n    \\}\n  \\}\n```\n      ","answer":"function (values) {\n        const { vet } = values\n        let inputArr = [...vet]// copiar o vetor\n        let stack = []\n        \n        while (inputArr.length) {\n          let aux = inputArr.shift()\n          if (aux % 2) stack.push(aux)\n          else inputArr.push(aux + 1)\n        }\n\n        stack.reverse();\n        return stack;\n      }","level":2,"keywords":["ordem de remoção","fila","pilha"]}],"linkedList":[{"id":"lista-add-node","subject":"Lista encadeada","text":"\nA lista duplamente encadeada **l** possui os seguintes elementos:\n```\n{lista=1:10:5}\n```\nSabendo que a função **addNode** cria e insere um novo nó entre os nós **ant** e **prox** que são recebidos por parâmetro.\n```\nnode *addNode(node *ant, int valor, node *prox) {\n  ...\n\\}\n```\nQual a nova sequência da lista, após a execução das seguintes instruções?\n```    \nint a = {a=1:10}, b = {b=1:10}, c = {c=1:10}, d = {d=1:10};\n\n{parte1}\n{parte2}\n{parte3}\n```  \n<parte1>\n  <item value=\"a\">novo = addNode(l-&gt;first, a, l-&gt;first-&gt;prox);</item>\n  <item value=\"b\">novo = addNode(NULL, a, l-&gt;first);</item>\n  <item value=\"c\">novo = addNode(l-&gt;first-&gt;prox, a, getNode(l, {lista[2]}));</item>\n</parte1>  \n<parte2>\n  <item value=\"a\">addNode(novo-&gt;ant, b, novo);</item>\n  <item value=\"b\">addNode(novo, b, novo-&gt;prox);</item>\n</parte2>\n<parte3>\n  <item value=\"a\">addNode(addNode(l-&gt;last-&gt;ant, c, l-&gt;last), d, l-&gt;last);</item>\n  <item value=\"b\">aux = l-&gt;last;\naddNode(aux, c, addNode(l-&gt;last, d, NULL));</item>\n</parte3>\n      ","answer":"function (values, options) {\n        let { lista, a, b, c, d } = values\n        let _lista = [...lista]\n        let op1 = options.parte1;\n        let op2 = options.parte2;\n        let op3 = options.parte3;\n\n        // Simulate a Doubly Linked List behaviour using an Array\n\n        // Simulate first instruction => addNode(l→first, \"a\", l→first→prox);\n        let pos;\n        switch(op1) {\n          case 'a': \n            pos = 1; break;\n          case 'b': \n            pos = 0; break;\n          case 'c': \n            pos = 2; break;\n        }\n        _lista.splice(pos, 0, a); \n\n        switch(op2) {\n          case 'a': _lista.splice(pos, 0, b);   break;\n          case 'b': _lista.splice(pos+1, 0, b); break;\n        }\n        \n        switch(op2) {\n          case 'a': \n          _lista.splice(_lista.length - 1, 0, c);\n          _lista.splice(_lista.length - 1, 0, d);\n          break;\n          case 'b':\n          _lista.push(c);\n          _lista.push(d);\n          break;\n        }\n       \n        return _lista\n      }","level":2,"keywords":["lista","lista duplamente encadeada"]},{"id":"lista-rec","subject":"Lista encadeada","text":"\nConsidere que a lista l possui os elementos **{vet=1:5:+6}**, nesta exata ordem. O que será impresso pela chamada: **f(l->first)**;\nConsiderando que a função f possui a seguinte implementação:\n```\nvoid f(node *n) \\{\n  if(n == NULL) \\{\n    return;\n  \\}\n  {codigo}\n\\}\n```  \n<codigo>\n  <item value=\"a\">printf(\"%d\", n-&gt;info); \n  if(n-&gt;prox != NULL) \\{\n    f(n-&gt;prox-&gt;prox);\n  \\}\n  printf(\"%d\", n-&gt;info);</item>\n  <item value=\"d\">printf(\"%d\", n-&gt;info); \n  if(n-&gt;prox != NULL) \\{\n    f(n-&gt;prox);\n  \\}</item>\n  <item value=\"e\">if(n-&gt;prox != NULL) \\{\n    f(n-&gt;prox);\n  \\}\n  printf(\"%d\", n-&gt;info);</item>\n</codigo>","answer":"function (values, options) {\n        let lista = values.vet\n        let vet = [...lista]\n        let opt = options.codigo\n        let answer = \"\";\n        \n        answer = vet[0] + \"\" + vet[2] + vet[4] + vet[4] + vet[2] + vet[0];\n        switch(opt) {\n          case 'a': \n            answer = vet[0] + \"\" + vet[2] + vet[4] + vet[4] + vet[2] + vet[0];\n             break;\n          case 'b': \n            answer = vet[0] + \"\" + vet[2] + vet[4] + vet[5] + vet[3] + vet[1];\n             break;\n          case 'c': \n            answer = vet[1] + \"\" + vet[3] + vet[5] + vet[4] + vet[2] + vet[0];\n             break;\n          case 'd': \n            answer = vet[0] + \"\" + vet[1] + vet[2] + vet[3] + vet[4] + vet[5];\n            break;\n          case 'e': \n            answer = vet[5] + \"\" + vet[4] + vet[3] + vet[2] + vet[1] + vet[0];\n            break;\n        }\n        \n        return [answer]\n      }","level":2,"keywords":["lista","lista encadeada","recursão"]}],"tree":[{"id":"árvore-bin-prop","subject":"Árvore binária","text":"\nEm uma árvore binária de altura **{height=3:15}**, qual {target} que esta árvore pode ter?\n<target>\n  <item value=\"folhas\">o número máximo de folhas</item>\n  <item value=\"nos\">o número máximo de nós</item>\n</target>\n","answer":"function (values, options) {\n        let altura  = values.height\n        let target = options.target\n        let answer = []\n        switch (target) {\n          case \"folhas\": answer.push(2**altura); break;\n          case \"nos\": answer.push(2**(altura+1)-1); break;\n        }\n        return answer\n      }","level":1,"keywords":["árvore binária","propriedades","folhas","nós"]},{"id":"árvore-bin-nos","subject":"Árvore binária","text":"\nSabendo que uma árvore binária possui **{num=3:500}** nós que podem ser dispostos de qualquer maneira.\nQual é a menor altura possível para esta árvore?\n","answer":"function (values, options) {\n        let num  = values.num\n        let answer = []\n        let i = 1;\n        let total = 2**(i+1) - 1\n        while(num > total) {\n          i++;\n          total = 2**(i+1) - 1\n        }\n        answer.push(i);\n        return answer\n      }","level":2,"keywords":["árvore binária","propriedades","folhas","nós"]},{"id":"árvore-bin-percurso","subject":"Árvore binária","text":"\nConsiderando que a árvore binária a seguir foi criada a partir do vetor **[{nums=1:8:8}]**:\n```\n         {tree}\n```\n\nQual é a sequência do percurso em **{ordem}** nesta árvore?\n\n<ordem>\n  <item value=\"pre\">pré-ordem</item>\n  <item value=\"em\">em-ordem</item>\n  <item value=\"pos\">pós-ordem</item>\n</ordem>\n<tree>\n  <item value=\"1\">{nums[0]}\n     /       \\\n    {nums[1]}         {nums[2]}\n /     \\    /    \\\n{nums[3]}       {nums[4]}  {nums[5]}      {nums[6]}\n       /  \n      {nums[7]}</item>\n   <item value=\"2\">{nums[0]}\n     /       \\\n    {nums[1]}         {nums[2]}\n     \\      /   \\\n      {nums[3]}    {nums[4]}     {nums[5]}\n     /    /  \n    {nums[6]}    {nums[7]}</item>\n   <item value=\"3\">{nums[0]}\n     /       \\\n    {nums[1]}          {nums[2]}\n     \\       /   \\\n      {nums[3]}     {nums[4]}     {nums[5]} \n             \\   / \n              {nums[6]} {nums[7]}</item>\n</tree>\n","answer":"function (values, options) {\n        let nums  = [...values.nums]\n        let ordem = options.ordem\n        let tree = options.tree\n        let itens = []\n        \n        switch(ordem) {\n          case \"pre\":\n            if (tree == 1)\n              itens = [0, 1, 3, 4, 7, 2, 5, 6];\n            else if (tree == 2)\n              itens = [0, 1, 3, 6, 2, 4, 7, 5];\n            else if (tree == 3)\n              itens = [0, 1, 3, 2, 4, 6, 5, 7];\n            break;\n          case \"em\":\n            if (tree == 1)\n              itens = [3, 1, 7, 4, 0, 5, 2, 6];\n            else if (tree == 2)\n              itens = [1, 6, 3, 0, 7, 4, 2, 5];\n            else if (tree == 3)\n              itens = [1, 3, 0, 4, 6, 2, 7, 5];\n            break;\n          case \"pos\":\n            if (tree == 1)\n              itens = [3, 7, 4, 1, 5, 6, 2, 0];\n            else if (tree == 2)\n              itens = [6, 3, 1, 7, 4, 5, 2, 0];\n            else if (tree == 3)\n              itens = [3, 1, 6, 4, 7, 5, 2, 0];\n            break;\n        }\n\n        let answer = [];\n        for (let i = 0; i<nums.length; i++) {\n          answer.push(nums[itens[i]]);\n        }\n        \n        return answer\n      }","level":2,"keywords":["árvore binária","percurso"]},{"id":"árvore-bin-func","subject":"Árvore binária","text":"\nSeja a variável t um ponteiro para a árvore binária criada a partir do vetor **[{nums=1:9:+8}]**:\n```\n         {tree}\n```\n\nQual é o resultado da chamada **f(t)**, considerando a função f a seguir\n```\n  {funcao}\n```\n\n<funcao>\n  <item value=\"somafolha\">int f(node *n) \\{\n    if (n == NULL) return 0;\n    if (isLeaf(n)) return info(n);\n  \n    return f(left(n)) + f(right(n));\n  \\}</item>\n  <item value=\"somapaifolha\">int f(node *n) \\{\n    if (n == NULL) return 0;\n    if (isLeaf(left(n)) || isLeaf(right(n))) return info(n);\n  \n    return f(left(n)) + f(right(n));\n  \\}</item>\n  <item value=\"somanaofolha\">int f(node *n) \\{\n    if (n == NULL) return 0;\n    if (isLeaf(n)) return 0;\n  \n    return f(left(n)) + f(right(n)) + info(n);\n  \\}\n  </item>\n  <item value=\"somatodos\">int f(node *n) \\{\n    if (n == NULL) return 0;\n  \n    return f(left(n)) + f(right(n)) + info(n);\n  \\}\n  </item>\n  <item value=\"somaum\">int f(node *n) \\{\n    if (n == NULL) return 0;\n    if (isLeaf(n)) return 0;\n    if (left(n) == NULL || right(n) == NULL) return info(n);\n  \n    return f(left(n)) + f(right(n));\n  \\}\n  </item>\n  <item value=\"somadois\">int f(node *n) \\{\n    int t = 0;\n    if (n == NULL) return 0;\n    if (isLeaf(n)) return 0;\n    if (left(n) != NULL &amp;&amp; right(n) != NULL) t = info(n);\n  \n    return f(left(n)) + f(right(n)) + t;\n  \\}\n  </item>\n</funcao>\n<tree>\n  <item value=\"1\">{nums[0]}\n     /       \\\n    {nums[1]}         {nums[2]}\n /     \\    /    \\\n{nums[3]}       {nums[4]}  {nums[5]}      {nums[6]}\n       /  \n      {nums[7]}</item>\n   <item value=\"2\">{nums[0]}\n     /       \\\n    {nums[1]}         {nums[2]}\n     \\      /   \\\n      {nums[3]}    {nums[4]}     {nums[5]}\n     /    /  \n    {nums[6]}    {nums[7]}</item>\n   <item value=\"3\">{nums[0]}\n     /       \\\n    {nums[1]}          {nums[2]}\n     \\       /   \\\n      {nums[3]}     {nums[4]}     {nums[5]} \n             \\   / \n              {nums[6]} {nums[7]}</item>\n</tree>\n","answer":"function (values, options) {\n        let nums  = [...values.nums]\n        let tree = parseInt(options.tree)\n        let func = options.funcao\n        let resp = {}\n        let answer = []\n\n        switch (tree) {\n          case 1:\n            resp = {\n              somafolha: nums[3] + nums[7] + nums[5] + nums[6],\n              somapaifolha: nums[1] + nums[2],\n              somanaofolha: nums[0] + nums[1] + nums[2] + nums[4],\n              somaum: nums[4],\n              somadois: nums[0] + nums[1] + nums[2]\n            }\n            break;\n          case 2:\n            resp = {\n              somafolha: nums[6] + nums[7] + nums[5],\n              somapaifolha: nums[3] + nums[2],\n              somanaofolha: nums[0] + nums[1] + nums[2] + nums[3] + nums[4],\n              somaum: nums[1] + nums[3] + nums[4],\n              somadois: nums[0] + nums[2]\n            }\n            break;\n          case 3:\n            resp = {\n              somafolha: nums[3] + nums[6] + nums[7],\n              somapaifolha: nums[1] + nums[4] + nums[5],\n              somanaofolha: nums[0] + nums[1] + nums[2] + nums[4] + nums[5],\n              somaum: nums[1] + nums[4] + nums[5],\n              somadois: nums[0] + nums[2]\n            }\n            break;\n        }\n        resp[\"somatodos\"] = nums.reduce((total, numero) => total + numero, 0);\n          \n        answer.push(resp[func]);\n        return answer\n      }","level":3,"keywords":["árvore binária","teste de mesa"]}],"btree":[{"id":"árvore-busca-altura","subject":"Árvore binária de busca","text":"\nDado que os números são inseridos em uma árvore binária de busca na respectiva ordem: ```{nums=1:20:+{6:10}}```.\nQual será a altura da árvore resultante?\n","answer":"function (values, options) {\n        let vet  = values.nums\n        let answer = []\n        let tree = null\n\n        function btinsert(tree, val) {\n          if (tree == null)\n            return {\n              info: val, left: null, right: null\n            }\n        \n          if (val < tree.info) {\n            tree.left = btinsert(tree.left, val);\n          } else {\n            tree.right = btinsert(tree.right, val);\n          }\n          return tree;\n        }\n\n        let altura = 0;\n        function height(tree, level) {\n          if (tree == null) return altura;\n          if (tree.left == null && tree.right == null) {\n            if (level > altura)\n              altura = level;\n            return altura;\n          }\n\n          height(tree.left, level + 1);\n          height(tree.right, level + 1);\n          return altura;\n        }\n\n        for (let i = 0; i < vet.length; i++) {\n          tree = btinsert(tree, vet[i]);\n        }\n        \n        answer.push(height(tree, 0));\n\n        return answer\n      }","level":2,"keywords":["árvore binária de busca","criação"]},{"id":"árvore-busca-percurso","subject":"Árvore binária de busca","text":"\nSuponha que os seguintes números ```{nums=1:9:9}``` foram inseridos nesta ordem em uma árvore binária de busca. \nQual é o resultado do percurso de **{percurso}** nesta árvore?\n<percurso>\n  <item value=\"pre\">pré-ordem</item>\n  <item value=\"pós\">pós-ordem</item>\n</percurso>\n","answer":"function (values, options) {\n        let vet  = values.nums\n        let answer = []\n        let tree = null\n\n        function btinsert(tree, val) {\n          if (tree == null)\n            return {\n              info: val, left: null, right: null\n            }\n        \n          if (val < tree.info) {\n            tree.left = btinsert(tree.left, val);\n          } else {\n            tree.right = btinsert(tree.right, val);\n          }\n          return tree;\n        }\n\n        for (let i = 0; i < vet.length; i++) {\n          tree = btinsert(tree, vet[i]);\n        }\n\n        let func;\n        if (options.percurso == \"pre\") {\n          func = function(tree) {\n            if (tree != null) {\n              answer.push(tree.info);\n              func(tree.left);\n              func(tree.right);\n            }\n          }\n        } else {\n          func = function(tree) {\n            if (tree != null) {\n              func(tree.left);\n              func(tree.right);\n              answer.push(tree.info);\n            }\n          }\n        }\n        \n        func(tree);\n        return answer\n      }","level":2,"keywords":["árvore binária de busca","criação","percurso"]},{"id":"árvore-busca-delete","subject":"Árvore binária de busca","text":"Considerando que uma árvore binária de busca é construída utilizando a seguinte sequência de números:\n```{nums=1:20:8}```\n\nQual será a soma de todas as folhas da árvore se o nó com valor **{nums[{i=0:7}]}** for removido?\n","answer":"function (values, options) {\n        let vet  = values.nums\n        let num = vet[values.i]\n        let answer = []\n        let tree = null\n\n        function btinsert(tree, val) {\n          if (tree == null)\n            return {\n              info: val, left: null, right: null\n            }\n        \n          if (val < tree.info) {\n            tree.left = btinsert(tree.left, val);\n          } else {\n            tree.right = btinsert(tree.right, val);\n          }\n          return tree;\n        }\n\n        function soma(tree) {\n          if (tree == null) return 0;\n          if (tree.left == null && tree.right == null) return tree.info;\n          return soma(tree.left) + soma(tree.right);\n        }\n\n        function busca(tree, key) {\n          if (tree == null || tree.info == key)\n            return tree;\n          if (key < tree.info)\n            return busca(tree.left, key);\n          else\n            return busca(tree.right, key);\n        }\n\n        function father(tree, node) {\n          if (tree == null) return null;\n          if (tree.left == node || tree.right == node) return tree;\n          \n          let p1 = father(tree.left, node);\n          if (p1 != null) return p1;\n          return father(tree.right, node); \n        }\n\n        function deleteNode(tree, val) {\n          let n = busca(tree, val);\n          let p = father(tree, n);\n          if (p == null) {\n            return deleteRoot(n);\n          }\n        \n          if (p.left == n) {\n            p.left = deleteRoot(n);\n          } else {\n            p.right = deleteRoot(n);\n          }\n        \n          return tree;\n        }\n\n        function deleteRoot(tree) {\n          let n, p;\n          if (tree.left == null) {\n            n = tree.right;\n          } else {\n            n = tree.left;\n            while(n.right != null) {\n               n = n.right;\n            }\n        \n            p = father(tree, n)\n            if (p != tree) {\n              p.right = n.left;\n              n.left = tree.left;\n            }\n            n.right = tree.right;\n          }\n\n          return n;\n        }\n\n        for (let i = 0; i < vet.length; i++) {\n          tree = btinsert(tree, vet[i]);\n        }\n        \n        tree = deleteNode(tree, num);\n        answer.push(soma(tree));\n\n        return answer\n      }","level":3,"keywords":["árvore binária de busca","exclusão","folhas"]},{"id":"árvore-busca-print","subject":"Árvore binária de busca","text":"Considerando a função a seguir:\n```      \n  int contador = 0; //Variavel global\n  void print(node *n, int k) \\{\n      {codigo}\n  \\}\n```\n      \nE a árvore binária de busca gerada pelos números:\n```{nums=1:15:10}```\n\nQual é o resultado da chamada **print(raiz, {a=2:3})**?\n<codigo>\n  <item value=\"a\">if (n != NULL &amp;&amp; contador &lt;= k) \\{\n        print(n-&gt;right, k);\n        contador++;\n        if (contador == k)\n          printf(\"%d\", n-&gt;info);\n        print(n-&gt;left, k);\n      \\}</item>\n  <item value=\"b\">if (n != NULL &amp;&amp; contador &lt;= k) \\{\n        print(n-&gt;left, k);\n        contador++;\n        if (contador == k)\n          printf(\"%d\", n-&gt;info);\n        print(n-&gt;right, k);\n      \\}</item>\n  <item value=\"a\">if (n != NULL &amp;&amp; contador &lt;= k) \\{\n        print(n-&gt;right, k);\n        if (contador == k)\n          printf(\"%d\", n-&gt;info);\n        contador++;\n        print(n-&gt;left, k);\n      \\}</item>\n  <item value=\"b\">if (n != NULL &amp;&amp; contador &lt;= k) \\{\n        print(n-&gt;left, k);\n        if (contador == k)\n          printf(\"%d\", n-&gt;info);\n        contador++;       \n        print(n-&gt;right, k);\n      \\}</item>\n</codigo>\n","answer":"function (values, options) {\n        let vet  = values.nums\n        let a = values.a\n        let answer = []\n        let tree = null\n\n        function btinsert(tree, val) {\n          if (tree == null)\n            return {\n              info: val, left: null, right: null\n            }\n        \n          if (val < tree.info) {\n            tree.left = btinsert(tree.left, val);\n          } else {\n            tree.right = btinsert(tree.right, val);\n          }\n          return tree;\n        }\n\n        let contador = 0;\n        let prt = null;\n        switch(options.codigo) {\n          case 'a':\n            prt = function (n, k) {\n              if (n != null && contador <= k) {\n                prt(n.right, k);\n                contador++;\n                if (contador == k)\n                  answer.push(n.info);\n                  prt(n.left, k);\n              }\n            }\n            break;\n          case 'b':\n            prt = function (n, k) {\n              if (n != null && contador <= k) {\n                prt(n.left, k);\n                contador++;\n                if (contador == k)\n                  answer.push(n.info);\n                  prt(n.right, k);\n              }\n            }\n            break;\n          case 'c':\n            prt = function (n, k) {\n                if (n != null && contador <= k) {\n                  prt(n.right, k);\n                  if (contador == k)\n                    answer.push(n.info);\n                  contador++;\n                  prt(n.left, k);\n                }\n                return resp;\n              }\n              break;\n          case 'd':\n            prt = function (n, k) {\n                if (n != null && contador <= k) {\n                  prt(n.left, k);\n                  if (contador == k)\n                    answer.push(n.info);\n                  contador++;\n                  prt(n.right, k);\n                }\n              }\n              break;\n        }\n        \n        for (let i = 0; i < vet.length; i++) {\n          tree = btinsert(tree, vet[i]);\n        }\n        \n        prt(tree, a);\n        return answer\n      }","level":3,"keywords":["árvore binária de busca","teste de mesa","percurso","recursividade"]}]}